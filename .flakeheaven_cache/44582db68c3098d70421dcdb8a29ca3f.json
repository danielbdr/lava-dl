{"results": [["pycodestyle", "E203", 30, 27, "whitespace before ':'", "            'threshold'     : threshold,   # delta unit threshold\n"], ["pycodestyle", "E203", 31, 27, "whitespace before ':'", "            'tau_grad'      : tau_grad,    # delta unit surrogate gradient relaxation parameter\n"], ["pycodestyle", "E203", 32, 27, "whitespace before ':'", "            'scale_grad'    : scale_grad,  # delta unit surrogate gradient scale parameter\n"], ["pycodestyle", "E203", 33, 27, "whitespace before ':'", "            'requires_grad' : False,  # trainable threshold\n"], ["pycodestyle", "E203", 34, 27, "whitespace before ':'", "            'shared_param'  : True,   # layer wise threshold\n"], ["pycodestyle", "E203", 38, 27, "whitespace before ':'", "            'activation'    : F.relu, # activation function\n"], ["pycodestyle", "E221", 43, 26, "multiple spaces before operator", "        self.normalize_std  = torch.tensor([0.229, 0.224, 0.225]).reshape([1, 3, 1, 1, 1])\n"], ["pycodestyle", "E231", 188, 23, "missing whitespace after ':'", "        model_keys = {k:False for k in saved_model.keys()}\n"], ["pycodestyle", "E241", 56, 56, "multiple spaces after ','", "            slayer.block.sigma_delta.Conv(neuron_kwargs,   3,  16, 3, padding=1, stride=2, weight_scale=1, **block_kwargs),\n"], ["pycodestyle", "E241", 56, 61, "multiple spaces after ','", "            slayer.block.sigma_delta.Conv(neuron_kwargs,   3,  16, 3, padding=1, stride=2, weight_scale=1, **block_kwargs),\n"], ["pycodestyle", "E241", 57, 56, "multiple spaces after ','", "            slayer.block.sigma_delta.Conv(neuron_kwargs,  16,  32, 3, padding=1, stride=2, weight_scale=1, **block_kwargs),\n"], ["pycodestyle", "E241", 57, 61, "multiple spaces after ','", "            slayer.block.sigma_delta.Conv(neuron_kwargs,  16,  32, 3, padding=1, stride=2, weight_scale=1, **block_kwargs),\n"], ["pycodestyle", "E241", 58, 56, "multiple spaces after ','", "            slayer.block.sigma_delta.Conv(neuron_kwargs,  32,  64, 3, padding=1, stride=2, weight_scale=1, **block_kwargs),\n"], ["pycodestyle", "E241", 58, 61, "multiple spaces after ','", "            slayer.block.sigma_delta.Conv(neuron_kwargs,  32,  64, 3, padding=1, stride=2, weight_scale=1, **block_kwargs),\n"], ["pycodestyle", "E241", 59, 56, "multiple spaces after ','", "            slayer.block.sigma_delta.Conv(neuron_kwargs,  64, 128, 3, padding=1, stride=2, weight_scale=3, **block_kwargs),\n"], ["pycodestyle", "E241", 64, 56, "multiple spaces after ','", "            slayer.block.sigma_delta.Conv(neuron_kwargs,  256,  256, 3, padding=1, stride=2, **block_kwargs),\n"], ["pycodestyle", "E241", 64, 62, "multiple spaces after ','", "            slayer.block.sigma_delta.Conv(neuron_kwargs,  256,  256, 3, padding=1, stride=2, **block_kwargs),\n"], ["pycodestyle", "E241", 65, 56, "multiple spaces after ','", "            slayer.block.sigma_delta.Conv(neuron_kwargs,  256,  512, 3, padding=1, stride=1, **block_kwargs),\n"], ["pycodestyle", "E241", 65, 62, "multiple spaces after ','", "            slayer.block.sigma_delta.Conv(neuron_kwargs,  256,  512, 3, padding=1, stride=1, **block_kwargs),\n"], ["pycodestyle", "E241", 66, 56, "multiple spaces after ','", "            slayer.block.sigma_delta.Conv(neuron_kwargs,  512, 1024, 3, padding=1, stride=1, **block_kwargs),\n"], ["pycodestyle", "E241", 67, 62, "multiple spaces after ','", "            slayer.block.sigma_delta.Conv(neuron_kwargs, 1024,  256, 1, padding=0, stride=1, **block_kwargs),\n"], ["pycodestyle", "E252", 107, 62, "missing whitespace around parameter equals", "    def forward(self, input, sparsity_monitor: SparsityMonitor=None):\n"], ["pycodestyle", "E252", 107, 63, "missing whitespace around parameter equals", "    def forward(self, input, sparsity_monitor: SparsityMonitor=None):\n"], ["pycodestyle", "E261", 29, 24, "at least two spaces before inline comment", "        sigma_params = { # sigma-delta neuron parameters\n"], ["pycodestyle", "E261", 38, 37, "at least two spaces before inline comment", "            'activation'    : F.relu, # activation function\n"], ["pycodestyle", "E266", 14, 0, "too many leading '#' for block comment", "#### sdnn_dual_head_yolo model\n"], ["pycodestyle", "E302", 16, 0, "expected 2 blank lines, found 1", "class Network(YOLOBase):\n"], ["pycodestyle", "E303", 127, 8, "too many blank lines (2)", "        h1_backend = backend        \n"], ["pycodestyle", "E402", 10, 0, "module level import not at top of file", "from yolo_base import YOLOBase\n"], ["pycodestyle", "E402", 12, 0, "module level import not at top of file", "from .model_utils import quantize_8bit, quantize_5bit, event_rate, SparsityMonitor\n"], ["pycodestyle", "E501", 12, 80, "line too long (82 > 80 characters)", "from .model_utils import quantize_8bit, quantize_5bit, event_rate, SparsityMonitor\n"], ["pycodestyle", "E501", 27, 80, "line too long (87 > 80 characters)", "        super().__init__(num_classes=num_classes, anchors=anchors, clamp_max=clamp_max)\n"], ["pycodestyle", "E501", 31, 80, "line too long (95 > 80 characters)", "            'tau_grad'      : tau_grad,    # delta unit surrogate gradient relaxation parameter\n"], ["pycodestyle", "E501", 32, 80, "line too long (90 > 80 characters)", "            'scale_grad'    : scale_grad,  # delta unit surrogate gradient scale parameter\n"], ["pycodestyle", "E501", 42, 80, "line too long (90 > 80 characters)", "        self.normalize_mean = torch.tensor([0.485, 0.456, 0.406]).reshape([1, 3, 1, 1, 1])\n"], ["pycodestyle", "E501", 43, 80, "line too long (90 > 80 characters)", "        self.normalize_std  = torch.tensor([0.229, 0.224, 0.225]).reshape([1, 3, 1, 1, 1])\n"], ["pycodestyle", "E501", 53, 80, "line too long (87 > 80 characters)", "        block_kwargs = dict(weight_norm=True, delay_shift=False, pre_hook_fx=quantizer)\n"], ["pycodestyle", "E501", 54, 80, "line too long (85 > 80 characters)", "        neuron_kwargs = {**sdnn_params, 'norm': slayer.neuron.norm.MeanOnlyBatchNorm}\n"], ["pycodestyle", "E501", 56, 80, "line too long (123 > 80 characters)", "            slayer.block.sigma_delta.Conv(neuron_kwargs,   3,  16, 3, padding=1, stride=2, weight_scale=1, **block_kwargs),\n"], ["pycodestyle", "E501", 57, 80, "line too long (123 > 80 characters)", "            slayer.block.sigma_delta.Conv(neuron_kwargs,  16,  32, 3, padding=1, stride=2, weight_scale=1, **block_kwargs),\n"], ["pycodestyle", "E501", 58, 80, "line too long (123 > 80 characters)", "            slayer.block.sigma_delta.Conv(neuron_kwargs,  32,  64, 3, padding=1, stride=2, weight_scale=1, **block_kwargs),\n"], ["pycodestyle", "E501", 59, 80, "line too long (123 > 80 characters)", "            slayer.block.sigma_delta.Conv(neuron_kwargs,  64, 128, 3, padding=1, stride=2, weight_scale=3, **block_kwargs),\n"], ["pycodestyle", "E501", 60, 80, "line too long (123 > 80 characters)", "            slayer.block.sigma_delta.Conv(neuron_kwargs, 128, 256, 3, padding=1, stride=1, weight_scale=3, **block_kwargs),\n"], ["pycodestyle", "E501", 64, 80, "line too long (109 > 80 characters)", "            slayer.block.sigma_delta.Conv(neuron_kwargs,  256,  256, 3, padding=1, stride=2, **block_kwargs),\n"], ["pycodestyle", "E501", 65, 80, "line too long (109 > 80 characters)", "            slayer.block.sigma_delta.Conv(neuron_kwargs,  256,  512, 3, padding=1, stride=1, **block_kwargs),\n"], ["pycodestyle", "E501", 66, 80, "line too long (109 > 80 characters)", "            slayer.block.sigma_delta.Conv(neuron_kwargs,  512, 1024, 3, padding=1, stride=1, **block_kwargs),\n"], ["pycodestyle", "E501", 67, 80, "line too long (109 > 80 characters)", "            slayer.block.sigma_delta.Conv(neuron_kwargs, 1024,  256, 1, padding=0, stride=1, **block_kwargs),\n"], ["pycodestyle", "E501", 71, 80, "line too long (107 > 80 characters)", "            slayer.block.sigma_delta.Conv(neuron_kwargs, 256, 512, 3, padding=1, stride=1, **block_kwargs),\n"], ["pycodestyle", "E501", 72, 80, "line too long (96 > 80 characters)", "            slayer.synapse.Conv(512, self.num_output, 1, padding=0, stride=1, **synapse_kwargs),\n"], ["pycodestyle", "E501", 77, 80, "line too long (107 > 80 characters)", "            slayer.block.sigma_delta.Conv(neuron_kwargs, 256, 128, 1, padding=0, stride=1, **block_kwargs),\n"], ["pycodestyle", "E501", 78, 80, "line too long (98 > 80 characters)", "            slayer.block.sigma_delta.Unpool(sdnn_params, kernel_size=2, stride=2, **block_kwargs),\n"], ["pycodestyle", "E501", 82, 80, "line too long (107 > 80 characters)", "            slayer.block.sigma_delta.Conv(neuron_kwargs, 384, 256, 3, padding=1, stride=1, **block_kwargs),\n"], ["pycodestyle", "E501", 83, 80, "line too long (96 > 80 characters)", "            slayer.synapse.Conv(256, self.num_output, 1, padding=0, stride=1, **synapse_kwargs),\n"], ["pycodestyle", "E501", 138, 80, "line too long (86 > 80 characters)", "            if has_sparisty_loss and isinstance(block, slayer.block.sigma_delta.Conv):\n"], ["pycodestyle", "E501", 152, 80, "line too long (86 > 80 characters)", "            if has_sparisty_loss and isinstance(block, slayer.block.sigma_delta.Conv):\n"], ["pycodestyle", "E501", 164, 80, "line too long (81 > 80 characters)", "        return output, torch.FloatTensor(count).reshape((1, -1)).to(input.device)\n"], ["pycodestyle", "E501", 191, 80, "line too long (106 > 80 characters)", "        self.input_blocks[0].neuron.bias.data = saved_model[f'input_blocks.0.neuron.bias'].data.to(device)\n"], ["pycodestyle", "E501", 192, 80, "line too long (128 > 80 characters)", "        self.input_blocks[0].neuron.delta.threshold.data = saved_model[f'input_blocks.0.neuron.delta.threshold'].data.to(device)\n"], ["pycodestyle", "E501", 198, 80, "line too long (105 > 80 characters)", "            self.backend_blocks[i].neuron.bias.data = saved_model[f'backend_blocks.{i}.neuron.bias'].data\n"], ["pycodestyle", "E501", 199, 80, "line too long (131 > 80 characters)", "            self.backend_blocks[i].neuron.norm.running_mean.data = saved_model[f'backend_blocks.{i}.neuron.norm.running_mean'].data\n"], ["pycodestyle", "E501", 200, 80, "line too long (127 > 80 characters)", "            self.backend_blocks[i].neuron.delta.threshold.data = saved_model[f'backend_blocks.{i}.neuron.delta.threshold'].data\n"], ["pycodestyle", "E501", 201, 80, "line too long (115 > 80 characters)", "            self.backend_blocks[i].synapse.weight_g.data = saved_model[f'backend_blocks.{i}.synapse.weight_g'].data\n"], ["pycodestyle", "E501", 202, 80, "line too long (115 > 80 characters)", "            self.backend_blocks[i].synapse.weight_v.data = saved_model[f'backend_blocks.{i}.synapse.weight_v'].data\n"], ["pycodestyle", "E501", 210, 80, "line too long (103 > 80 characters)", "            self.head1_backend[i].neuron.bias.data = saved_model[f'head1_backend.{i}.neuron.bias'].data\n"], ["pycodestyle", "E501", 211, 80, "line too long (129 > 80 characters)", "            self.head1_backend[i].neuron.norm.running_mean.data = saved_model[f'head1_backend.{i}.neuron.norm.running_mean'].data\n"], ["pycodestyle", "E501", 212, 80, "line too long (125 > 80 characters)", "            self.head1_backend[i].neuron.delta.threshold.data = saved_model[f'head1_backend.{i}.neuron.delta.threshold'].data\n"], ["pycodestyle", "E501", 213, 80, "line too long (113 > 80 characters)", "            self.head1_backend[i].synapse.weight_g.data = saved_model[f'head1_backend.{i}.synapse.weight_g'].data\n"], ["pycodestyle", "E501", 214, 80, "line too long (113 > 80 characters)", "            self.head1_backend[i].synapse.weight_v.data = saved_model[f'head1_backend.{i}.synapse.weight_v'].data\n"], ["pycodestyle", "E501", 222, 80, "line too long (103 > 80 characters)", "            self.head2_backend[i].neuron.bias.data = saved_model[f'head2_backend.{i}.neuron.bias'].data\n"], ["pycodestyle", "E501", 223, 80, "line too long (125 > 80 characters)", "            self.head2_backend[i].neuron.delta.threshold.data = saved_model[f'head2_backend.{i}.neuron.delta.threshold'].data\n"], ["pycodestyle", "E501", 224, 80, "line too long (113 > 80 characters)", "            self.head2_backend[i].synapse.weight_g.data = saved_model[f'head2_backend.{i}.synapse.weight_g'].data\n"], ["pycodestyle", "E501", 225, 80, "line too long (113 > 80 characters)", "            self.head2_backend[i].synapse.weight_v.data = saved_model[f'head2_backend.{i}.synapse.weight_v'].data\n"], ["pycodestyle", "E501", 231, 80, "line too long (83 > 80 characters)", "            if f'head2_backend.{i}.neuron.norm.running_mean' in saved_model.keys():\n"], ["pycodestyle", "E501", 233, 80, "line too long (133 > 80 characters)", "                self.head2_backend[i].neuron.norm.running_mean.data = saved_model[f'head2_backend.{i}.neuron.norm.running_mean'].data\n"], ["pycodestyle", "E501", 237, 80, "line too long (97 > 80 characters)", "        self.head1_blocks[i].neuron.bias.data = saved_model[f'head1_blocks.{i}.neuron.bias'].data\n"], ["pycodestyle", "E501", 238, 80, "line too long (123 > 80 characters)", "        self.head1_blocks[i].neuron.norm.running_mean.data = saved_model[f'head1_blocks.{i}.neuron.norm.running_mean'].data\n"], ["pycodestyle", "E501", 239, 80, "line too long (119 > 80 characters)", "        self.head1_blocks[i].neuron.delta.threshold.data = saved_model[f'head1_blocks.{i}.neuron.delta.threshold'].data\n"], ["pycodestyle", "E501", 240, 80, "line too long (107 > 80 characters)", "        self.head1_blocks[i].synapse.weight_g.data = saved_model[f'head1_blocks.{i}.synapse.weight_g'].data\n"], ["pycodestyle", "E501", 241, 80, "line too long (107 > 80 characters)", "        self.head1_blocks[i].synapse.weight_v.data = saved_model[f'head1_blocks.{i}.synapse.weight_v'].data\n"], ["pycodestyle", "E501", 248, 80, "line too long (97 > 80 characters)", "        self.head2_blocks[i].neuron.bias.data = saved_model[f'head2_blocks.{i}.neuron.bias'].data\n"], ["pycodestyle", "E501", 249, 80, "line too long (123 > 80 characters)", "        self.head2_blocks[i].neuron.norm.running_mean.data = saved_model[f'head2_blocks.{i}.neuron.norm.running_mean'].data\n"], ["pycodestyle", "E501", 250, 80, "line too long (119 > 80 characters)", "        self.head2_blocks[i].neuron.delta.threshold.data = saved_model[f'head2_blocks.{i}.neuron.delta.threshold'].data\n"], ["pycodestyle", "E501", 251, 80, "line too long (107 > 80 characters)", "        self.head2_blocks[i].synapse.weight_g.data = saved_model[f'head2_blocks.{i}.synapse.weight_g'].data\n"], ["pycodestyle", "E501", 252, 80, "line too long (107 > 80 characters)", "        self.head2_blocks[i].synapse.weight_v.data = saved_model[f'head2_blocks.{i}.synapse.weight_v'].data\n"], ["pycodestyle", "E501", 259, 80, "line too long (102 > 80 characters)", "        if self.head1_blocks[1].weight.data.shape == saved_model[f'head1_blocks.1.weight'].data.shape:\n"], ["pycodestyle", "E501", 260, 80, "line too long (89 > 80 characters)", "            self.head1_blocks[1].weight.data = saved_model[f'head1_blocks.1.weight'].data\n"], ["pycodestyle", "E501", 261, 80, "line too long (89 > 80 characters)", "            self.head2_blocks[1].weight.data = saved_model[f'head2_blocks.1.weight'].data\n"], ["pycodestyle", "W291", 127, 28, "trailing whitespace", "        h1_backend = backend        \n"], ["pycodestyle", "W291", 134, 26, "trailing whitespace", "        head1 = h1_backend        \n"], ["pycodestyle", "W293", 118, 0, "blank line contains whitespace", "        \n"], ["pycodestyle", "W293", 163, 0, "blank line contains whitespace", "        \n"], ["pycodestyle", "W293", 172, 0, "blank line contains whitespace", "        \n"], ["pycodestyle", "W293", 220, 0, "blank line contains whitespace", "        \n"], ["pycodestyle", "W293", 235, 0, "blank line contains whitespace", "        \n"], ["pycodestyle", "W293", 247, 0, "blank line contains whitespace", "        \n"], ["pycodestyle", "W503", 171, 20, "line break before binary operator", "                    and b.synapse.weight.requires_grad]\n"]], "digest": "5cb3a43fade0d87855e100fa91a761e2"}