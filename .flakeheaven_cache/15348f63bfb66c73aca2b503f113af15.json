{"results": [["pycodestyle", "E226", 123, 47, "missing whitespace around arithmetic operator", "                if k == max_iterations_temporal-1:  # last iteration is classic NMS\n"], ["pycodestyle", "E226", 135, 62, "missing whitespace around arithmetic operator", "                            ious * label_match > nms_threshold*temporal_scaling_threshold\n"], ["pycodestyle", "E226", 143, 42, "missing whitespace around arithmetic operator", "                        detections01[:, 4]*scaling_prob[0], torch.tensor(1.0))\n"], ["pycodestyle", "E226", 147, 91, "missing whitespace around arithmetic operator", "                        [detections01, detections00], dim=0) if k < max_iterations_temporal-1 else detections01\n"], ["pycodestyle", "E501", 117, 80, "line too long (91 > 80 characters)", "            if len(dets_[b_n]) == 1:  # loads the first frame NMS components discarding NMS\n"], ["pycodestyle", "E501", 123, 80, "line too long (83 > 80 characters)", "                if k == max_iterations_temporal-1:  # last iteration is classic NMS\n"], ["pycodestyle", "E501", 133, 80, "line too long (97 > 80 characters)", "                            detections1[:, 5].reshape(-1, 1) == detections0[:, 5].reshape(1, -1))\n"], ["pycodestyle", "E501", 135, 80, "line too long (89 > 80 characters)", "                            ious * label_match > nms_threshold*temporal_scaling_threshold\n"], ["pycodestyle", "E501", 136, 80, "line too long (95 > 80 characters)", "                        ).long().triu(1).sum(dim=0, keepdim=True).T.expand_as(detections0) == 0\n"], ["pycodestyle", "E501", 141, 80, "line too long (99 > 80 characters)", "                    # rescaling confidence of bboxes if overlapping and belonging to the same label\n"], ["pycodestyle", "E501", 147, 80, "line too long (111 > 80 characters)", "                        [detections01, detections00], dim=0) if k < max_iterations_temporal-1 else detections01\n"], ["pycodestyle", "W291", 31, 70, "trailing whitespace", "    \"\"\"Performs temporal Non-Maximal suppression of the input predictions. \n    First a basic filtering of the bounding boxes based on a minimum confidence \n    threshold are eliminated. Subsequently we operate a non-maximal suppression \n    is performed maching bboxes over two successive frames. A non-maximal \n    threshold is used to determine if the two bounding boxes represent the same \n    object, above(below) which the likelihood of the object is \n    increased(decreased). It supports batch inputs.\n\n\n    import temporal_NMS as t_nms\n    ### The class is self initialized!! no need to initialize it. \n    ### Instances can be accessed directly calling class_name.instance\n    ### Calling the frame predictions to be analyzed, will automatically \n    initialize variables, for example: \n    detections = [t_nms.next(predictions[...,t]) for t in T]\n    ### to reset to zero frame data call:\n    t_nms.reset()\n\n    Parameters\n    ----------\n    pred : List[torch.tensor]\n        List of bounding box predictions per batch in\n        (x_center, y_center, width, height) format.\n    conf_threshold : float, optional\n        Confidence threshold, by default 0.5.\n    nms_threshold : float, optional\n        Non maximal overlap threshold, by default 0.4.\n    merge_conf : bool, optional\n        Flag indicating whether to merge objectness score with classification\n        confidence, by default True.\n    max_iterations_temporal : int, optional\n        Maximum limit of temporal iterations (default 15) that scale the class\n        likelihood given the neighboring bboxes.\n    temporal_scaling_threshold : float, optional\n        scaling factor on the nms_threshold for filtering off ious\n    scaling_prob: List of two floats [float, float]\n        scaling of the keep [0] and remove [1] probabilities of neighboring \n        bboxes\n    k_frames: int, optionl - default 2\n\n    Returns\n    -------\n    List[torch.tensor]\n        Non-maximal filterered prediction outputs per batch.\n    \"\"\"\n"], ["pycodestyle", "W291", 32, 79, "trailing whitespace", "    \"\"\"Performs temporal Non-Maximal suppression of the input predictions. \n    First a basic filtering of the bounding boxes based on a minimum confidence \n    threshold are eliminated. Subsequently we operate a non-maximal suppression \n    is performed maching bboxes over two successive frames. A non-maximal \n    threshold is used to determine if the two bounding boxes represent the same \n    object, above(below) which the likelihood of the object is \n    increased(decreased). It supports batch inputs.\n\n\n    import temporal_NMS as t_nms\n    ### The class is self initialized!! no need to initialize it. \n    ### Instances can be accessed directly calling class_name.instance\n    ### Calling the frame predictions to be analyzed, will automatically \n    initialize variables, for example: \n    detections = [t_nms.next(predictions[...,t]) for t in T]\n    ### to reset to zero frame data call:\n    t_nms.reset()\n\n    Parameters\n    ----------\n    pred : List[torch.tensor]\n        List of bounding box predictions per batch in\n        (x_center, y_center, width, height) format.\n    conf_threshold : float, optional\n        Confidence threshold, by default 0.5.\n    nms_threshold : float, optional\n        Non maximal overlap threshold, by default 0.4.\n    merge_conf : bool, optional\n        Flag indicating whether to merge objectness score with classification\n        confidence, by default True.\n    max_iterations_temporal : int, optional\n        Maximum limit of temporal iterations (default 15) that scale the class\n        likelihood given the neighboring bboxes.\n    temporal_scaling_threshold : float, optional\n        scaling factor on the nms_threshold for filtering off ious\n    scaling_prob: List of two floats [float, float]\n        scaling of the keep [0] and remove [1] probabilities of neighboring \n        bboxes\n    k_frames: int, optionl - default 2\n\n    Returns\n    -------\n    List[torch.tensor]\n        Non-maximal filterered prediction outputs per batch.\n    \"\"\"\n"], ["pycodestyle", "W291", 33, 79, "trailing whitespace", "    \"\"\"Performs temporal Non-Maximal suppression of the input predictions. \n    First a basic filtering of the bounding boxes based on a minimum confidence \n    threshold are eliminated. Subsequently we operate a non-maximal suppression \n    is performed maching bboxes over two successive frames. A non-maximal \n    threshold is used to determine if the two bounding boxes represent the same \n    object, above(below) which the likelihood of the object is \n    increased(decreased). It supports batch inputs.\n\n\n    import temporal_NMS as t_nms\n    ### The class is self initialized!! no need to initialize it. \n    ### Instances can be accessed directly calling class_name.instance\n    ### Calling the frame predictions to be analyzed, will automatically \n    initialize variables, for example: \n    detections = [t_nms.next(predictions[...,t]) for t in T]\n    ### to reset to zero frame data call:\n    t_nms.reset()\n\n    Parameters\n    ----------\n    pred : List[torch.tensor]\n        List of bounding box predictions per batch in\n        (x_center, y_center, width, height) format.\n    conf_threshold : float, optional\n        Confidence threshold, by default 0.5.\n    nms_threshold : float, optional\n        Non maximal overlap threshold, by default 0.4.\n    merge_conf : bool, optional\n        Flag indicating whether to merge objectness score with classification\n        confidence, by default True.\n    max_iterations_temporal : int, optional\n        Maximum limit of temporal iterations (default 15) that scale the class\n        likelihood given the neighboring bboxes.\n    temporal_scaling_threshold : float, optional\n        scaling factor on the nms_threshold for filtering off ious\n    scaling_prob: List of two floats [float, float]\n        scaling of the keep [0] and remove [1] probabilities of neighboring \n        bboxes\n    k_frames: int, optionl - default 2\n\n    Returns\n    -------\n    List[torch.tensor]\n        Non-maximal filterered prediction outputs per batch.\n    \"\"\"\n"], ["pycodestyle", "W291", 34, 73, "trailing whitespace", "    \"\"\"Performs temporal Non-Maximal suppression of the input predictions. \n    First a basic filtering of the bounding boxes based on a minimum confidence \n    threshold are eliminated. Subsequently we operate a non-maximal suppression \n    is performed maching bboxes over two successive frames. A non-maximal \n    threshold is used to determine if the two bounding boxes represent the same \n    object, above(below) which the likelihood of the object is \n    increased(decreased). It supports batch inputs.\n\n\n    import temporal_NMS as t_nms\n    ### The class is self initialized!! no need to initialize it. \n    ### Instances can be accessed directly calling class_name.instance\n    ### Calling the frame predictions to be analyzed, will automatically \n    initialize variables, for example: \n    detections = [t_nms.next(predictions[...,t]) for t in T]\n    ### to reset to zero frame data call:\n    t_nms.reset()\n\n    Parameters\n    ----------\n    pred : List[torch.tensor]\n        List of bounding box predictions per batch in\n        (x_center, y_center, width, height) format.\n    conf_threshold : float, optional\n        Confidence threshold, by default 0.5.\n    nms_threshold : float, optional\n        Non maximal overlap threshold, by default 0.4.\n    merge_conf : bool, optional\n        Flag indicating whether to merge objectness score with classification\n        confidence, by default True.\n    max_iterations_temporal : int, optional\n        Maximum limit of temporal iterations (default 15) that scale the class\n        likelihood given the neighboring bboxes.\n    temporal_scaling_threshold : float, optional\n        scaling factor on the nms_threshold for filtering off ious\n    scaling_prob: List of two floats [float, float]\n        scaling of the keep [0] and remove [1] probabilities of neighboring \n        bboxes\n    k_frames: int, optionl - default 2\n\n    Returns\n    -------\n    List[torch.tensor]\n        Non-maximal filterered prediction outputs per batch.\n    \"\"\"\n"], ["pycodestyle", "W291", 35, 79, "trailing whitespace", "    \"\"\"Performs temporal Non-Maximal suppression of the input predictions. \n    First a basic filtering of the bounding boxes based on a minimum confidence \n    threshold are eliminated. Subsequently we operate a non-maximal suppression \n    is performed maching bboxes over two successive frames. A non-maximal \n    threshold is used to determine if the two bounding boxes represent the same \n    object, above(below) which the likelihood of the object is \n    increased(decreased). It supports batch inputs.\n\n\n    import temporal_NMS as t_nms\n    ### The class is self initialized!! no need to initialize it. \n    ### Instances can be accessed directly calling class_name.instance\n    ### Calling the frame predictions to be analyzed, will automatically \n    initialize variables, for example: \n    detections = [t_nms.next(predictions[...,t]) for t in T]\n    ### to reset to zero frame data call:\n    t_nms.reset()\n\n    Parameters\n    ----------\n    pred : List[torch.tensor]\n        List of bounding box predictions per batch in\n        (x_center, y_center, width, height) format.\n    conf_threshold : float, optional\n        Confidence threshold, by default 0.5.\n    nms_threshold : float, optional\n        Non maximal overlap threshold, by default 0.4.\n    merge_conf : bool, optional\n        Flag indicating whether to merge objectness score with classification\n        confidence, by default True.\n    max_iterations_temporal : int, optional\n        Maximum limit of temporal iterations (default 15) that scale the class\n        likelihood given the neighboring bboxes.\n    temporal_scaling_threshold : float, optional\n        scaling factor on the nms_threshold for filtering off ious\n    scaling_prob: List of two floats [float, float]\n        scaling of the keep [0] and remove [1] probabilities of neighboring \n        bboxes\n    k_frames: int, optionl - default 2\n\n    Returns\n    -------\n    List[torch.tensor]\n        Non-maximal filterered prediction outputs per batch.\n    \"\"\"\n"], ["pycodestyle", "W291", 36, 62, "trailing whitespace", "    \"\"\"Performs temporal Non-Maximal suppression of the input predictions. \n    First a basic filtering of the bounding boxes based on a minimum confidence \n    threshold are eliminated. Subsequently we operate a non-maximal suppression \n    is performed maching bboxes over two successive frames. A non-maximal \n    threshold is used to determine if the two bounding boxes represent the same \n    object, above(below) which the likelihood of the object is \n    increased(decreased). It supports batch inputs.\n\n\n    import temporal_NMS as t_nms\n    ### The class is self initialized!! no need to initialize it. \n    ### Instances can be accessed directly calling class_name.instance\n    ### Calling the frame predictions to be analyzed, will automatically \n    initialize variables, for example: \n    detections = [t_nms.next(predictions[...,t]) for t in T]\n    ### to reset to zero frame data call:\n    t_nms.reset()\n\n    Parameters\n    ----------\n    pred : List[torch.tensor]\n        List of bounding box predictions per batch in\n        (x_center, y_center, width, height) format.\n    conf_threshold : float, optional\n        Confidence threshold, by default 0.5.\n    nms_threshold : float, optional\n        Non maximal overlap threshold, by default 0.4.\n    merge_conf : bool, optional\n        Flag indicating whether to merge objectness score with classification\n        confidence, by default True.\n    max_iterations_temporal : int, optional\n        Maximum limit of temporal iterations (default 15) that scale the class\n        likelihood given the neighboring bboxes.\n    temporal_scaling_threshold : float, optional\n        scaling factor on the nms_threshold for filtering off ious\n    scaling_prob: List of two floats [float, float]\n        scaling of the keep [0] and remove [1] probabilities of neighboring \n        bboxes\n    k_frames: int, optionl - default 2\n\n    Returns\n    -------\n    List[torch.tensor]\n        Non-maximal filterered prediction outputs per batch.\n    \"\"\"\n"], ["pycodestyle", "W291", 41, 65, "trailing whitespace", "    \"\"\"Performs temporal Non-Maximal suppression of the input predictions. \n    First a basic filtering of the bounding boxes based on a minimum confidence \n    threshold are eliminated. Subsequently we operate a non-maximal suppression \n    is performed maching bboxes over two successive frames. A non-maximal \n    threshold is used to determine if the two bounding boxes represent the same \n    object, above(below) which the likelihood of the object is \n    increased(decreased). It supports batch inputs.\n\n\n    import temporal_NMS as t_nms\n    ### The class is self initialized!! no need to initialize it. \n    ### Instances can be accessed directly calling class_name.instance\n    ### Calling the frame predictions to be analyzed, will automatically \n    initialize variables, for example: \n    detections = [t_nms.next(predictions[...,t]) for t in T]\n    ### to reset to zero frame data call:\n    t_nms.reset()\n\n    Parameters\n    ----------\n    pred : List[torch.tensor]\n        List of bounding box predictions per batch in\n        (x_center, y_center, width, height) format.\n    conf_threshold : float, optional\n        Confidence threshold, by default 0.5.\n    nms_threshold : float, optional\n        Non maximal overlap threshold, by default 0.4.\n    merge_conf : bool, optional\n        Flag indicating whether to merge objectness score with classification\n        confidence, by default True.\n    max_iterations_temporal : int, optional\n        Maximum limit of temporal iterations (default 15) that scale the class\n        likelihood given the neighboring bboxes.\n    temporal_scaling_threshold : float, optional\n        scaling factor on the nms_threshold for filtering off ious\n    scaling_prob: List of two floats [float, float]\n        scaling of the keep [0] and remove [1] probabilities of neighboring \n        bboxes\n    k_frames: int, optionl - default 2\n\n    Returns\n    -------\n    List[torch.tensor]\n        Non-maximal filterered prediction outputs per batch.\n    \"\"\"\n"], ["pycodestyle", "W291", 43, 72, "trailing whitespace", "    \"\"\"Performs temporal Non-Maximal suppression of the input predictions. \n    First a basic filtering of the bounding boxes based on a minimum confidence \n    threshold are eliminated. Subsequently we operate a non-maximal suppression \n    is performed maching bboxes over two successive frames. A non-maximal \n    threshold is used to determine if the two bounding boxes represent the same \n    object, above(below) which the likelihood of the object is \n    increased(decreased). It supports batch inputs.\n\n\n    import temporal_NMS as t_nms\n    ### The class is self initialized!! no need to initialize it. \n    ### Instances can be accessed directly calling class_name.instance\n    ### Calling the frame predictions to be analyzed, will automatically \n    initialize variables, for example: \n    detections = [t_nms.next(predictions[...,t]) for t in T]\n    ### to reset to zero frame data call:\n    t_nms.reset()\n\n    Parameters\n    ----------\n    pred : List[torch.tensor]\n        List of bounding box predictions per batch in\n        (x_center, y_center, width, height) format.\n    conf_threshold : float, optional\n        Confidence threshold, by default 0.5.\n    nms_threshold : float, optional\n        Non maximal overlap threshold, by default 0.4.\n    merge_conf : bool, optional\n        Flag indicating whether to merge objectness score with classification\n        confidence, by default True.\n    max_iterations_temporal : int, optional\n        Maximum limit of temporal iterations (default 15) that scale the class\n        likelihood given the neighboring bboxes.\n    temporal_scaling_threshold : float, optional\n        scaling factor on the nms_threshold for filtering off ious\n    scaling_prob: List of two floats [float, float]\n        scaling of the keep [0] and remove [1] probabilities of neighboring \n        bboxes\n    k_frames: int, optionl - default 2\n\n    Returns\n    -------\n    List[torch.tensor]\n        Non-maximal filterered prediction outputs per batch.\n    \"\"\"\n"], ["pycodestyle", "W291", 44, 38, "trailing whitespace", "    \"\"\"Performs temporal Non-Maximal suppression of the input predictions. \n    First a basic filtering of the bounding boxes based on a minimum confidence \n    threshold are eliminated. Subsequently we operate a non-maximal suppression \n    is performed maching bboxes over two successive frames. A non-maximal \n    threshold is used to determine if the two bounding boxes represent the same \n    object, above(below) which the likelihood of the object is \n    increased(decreased). It supports batch inputs.\n\n\n    import temporal_NMS as t_nms\n    ### The class is self initialized!! no need to initialize it. \n    ### Instances can be accessed directly calling class_name.instance\n    ### Calling the frame predictions to be analyzed, will automatically \n    initialize variables, for example: \n    detections = [t_nms.next(predictions[...,t]) for t in T]\n    ### to reset to zero frame data call:\n    t_nms.reset()\n\n    Parameters\n    ----------\n    pred : List[torch.tensor]\n        List of bounding box predictions per batch in\n        (x_center, y_center, width, height) format.\n    conf_threshold : float, optional\n        Confidence threshold, by default 0.5.\n    nms_threshold : float, optional\n        Non maximal overlap threshold, by default 0.4.\n    merge_conf : bool, optional\n        Flag indicating whether to merge objectness score with classification\n        confidence, by default True.\n    max_iterations_temporal : int, optional\n        Maximum limit of temporal iterations (default 15) that scale the class\n        likelihood given the neighboring bboxes.\n    temporal_scaling_threshold : float, optional\n        scaling factor on the nms_threshold for filtering off ious\n    scaling_prob: List of two floats [float, float]\n        scaling of the keep [0] and remove [1] probabilities of neighboring \n        bboxes\n    k_frames: int, optionl - default 2\n\n    Returns\n    -------\n    List[torch.tensor]\n        Non-maximal filterered prediction outputs per batch.\n    \"\"\"\n"], ["pycodestyle", "W291", 67, 75, "trailing whitespace", "    \"\"\"Performs temporal Non-Maximal suppression of the input predictions. \n    First a basic filtering of the bounding boxes based on a minimum confidence \n    threshold are eliminated. Subsequently we operate a non-maximal suppression \n    is performed maching bboxes over two successive frames. A non-maximal \n    threshold is used to determine if the two bounding boxes represent the same \n    object, above(below) which the likelihood of the object is \n    increased(decreased). It supports batch inputs.\n\n\n    import temporal_NMS as t_nms\n    ### The class is self initialized!! no need to initialize it. \n    ### Instances can be accessed directly calling class_name.instance\n    ### Calling the frame predictions to be analyzed, will automatically \n    initialize variables, for example: \n    detections = [t_nms.next(predictions[...,t]) for t in T]\n    ### to reset to zero frame data call:\n    t_nms.reset()\n\n    Parameters\n    ----------\n    pred : List[torch.tensor]\n        List of bounding box predictions per batch in\n        (x_center, y_center, width, height) format.\n    conf_threshold : float, optional\n        Confidence threshold, by default 0.5.\n    nms_threshold : float, optional\n        Non maximal overlap threshold, by default 0.4.\n    merge_conf : bool, optional\n        Flag indicating whether to merge objectness score with classification\n        confidence, by default True.\n    max_iterations_temporal : int, optional\n        Maximum limit of temporal iterations (default 15) that scale the class\n        likelihood given the neighboring bboxes.\n    temporal_scaling_threshold : float, optional\n        scaling factor on the nms_threshold for filtering off ious\n    scaling_prob: List of two floats [float, float]\n        scaling of the keep [0] and remove [1] probabilities of neighboring \n        bboxes\n    k_frames: int, optionl - default 2\n\n    Returns\n    -------\n    List[torch.tensor]\n        Non-maximal filterered prediction outputs per batch.\n    \"\"\"\n"], ["pycodestyle", "W503", 212, 20, "line break before binary operator", "                    == detections[:, 5].reshape(1, -1)\n"], ["pycodestyle", "W503", 523, 8, "line break before binary operator", "        != ann1['annotation']['size']['height']\n"], ["pycodestyle", "W503", 531, 8, "line break before binary operator", "        != ann1['annotation']['size']['width']\n"], ["pycodestyle", "W503", 539, 12, "line break before binary operator", "            + ann1['annotation']['object']}\n"], ["pycodestyle", "W503", 735, 16, "line break before binary operator", "                * 255\n"], ["pycodestyle", "W503", 753, 16, "line break before binary operator", "                * 255\n"]], "digest": "79f2d1f5a8a064e6bc6350e0fb138526"}