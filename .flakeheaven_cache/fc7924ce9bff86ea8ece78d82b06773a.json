{"results": [["pycodestyle", "E203", 28, 27, "whitespace before ':'", "            'threshold'     : threshold,   # delta unit threshold\n"], ["pycodestyle", "E203", 29, 27, "whitespace before ':'", "            'tau_grad'      : tau_grad,    # delta unit surrogate gradient relaxation parameter\n"], ["pycodestyle", "E203", 30, 27, "whitespace before ':'", "            'scale_grad'    : scale_grad,  # delta unit surrogate gradient scale parameter\n"], ["pycodestyle", "E203", 31, 27, "whitespace before ':'", "            'requires_grad' : False,  # trainable threshold\n"], ["pycodestyle", "E203", 32, 27, "whitespace before ':'", "            'shared_param'  : True,   # layer wise threshold\n"], ["pycodestyle", "E203", 36, 27, "whitespace before ':'", "            'activation'    : F.relu, # activation function\n"], ["pycodestyle", "E221", 41, 26, "multiple spaces before operator", "        self.normalize_std  = torch.tensor([0.229, 0.224, 0.225]).reshape([1, 3, 1, 1, 1])\n"], ["pycodestyle", "E231", 162, 23, "missing whitespace after ':'", "        model_keys = {k:False for k in saved_model.keys()}\n"], ["pycodestyle", "E241", 57, 56, "multiple spaces after ','", "            slayer.block.sigma_delta.Conv(neuron_kwargs,   3,  8, 3, padding=1, stride=2, weight_scale=1, **block_8_kwargs),\n"], ["pycodestyle", "E241", 57, 61, "multiple spaces after ','", "            slayer.block.sigma_delta.Conv(neuron_kwargs,   3,  8, 3, padding=1, stride=2, weight_scale=1, **block_8_kwargs),\n"], ["pycodestyle", "E241", 58, 56, "multiple spaces after ','", "            slayer.block.sigma_delta.Conv(neuron_kwargs,  8,  16, 3, padding=1, stride=2, weight_scale=1, **block_8_kwargs),\n"], ["pycodestyle", "E241", 58, 60, "multiple spaces after ','", "            slayer.block.sigma_delta.Conv(neuron_kwargs,  8,  16, 3, padding=1, stride=2, weight_scale=1, **block_8_kwargs),\n"], ["pycodestyle", "E241", 59, 56, "multiple spaces after ','", "            slayer.block.sigma_delta.Conv(neuron_kwargs,  16,  32, 3, padding=1, stride=2, weight_scale=1, **block_8_kwargs),\n"], ["pycodestyle", "E241", 59, 61, "multiple spaces after ','", "            slayer.block.sigma_delta.Conv(neuron_kwargs,  16,  32, 3, padding=1, stride=2, weight_scale=1, **block_8_kwargs),\n"], ["pycodestyle", "E241", 60, 56, "multiple spaces after ','", "            slayer.block.sigma_delta.Conv(neuron_kwargs,  32, 64, 3, padding=1, stride=2, weight_scale=3, **block_8_kwargs),\n"], ["pycodestyle", "E252", 73, 62, "missing whitespace around parameter equals", "    def forward(self, input, sparsity_monitor: SparsityMonitor=None):\n"], ["pycodestyle", "E252", 73, 63, "missing whitespace around parameter equals", "    def forward(self, input, sparsity_monitor: SparsityMonitor=None):\n"], ["pycodestyle", "E261", 27, 24, "at least two spaces before inline comment", "        sigma_params = { # sigma-delta neuron parameters\n"], ["pycodestyle", "E261", 36, 37, "at least two spaces before inline comment", "            'activation'    : F.relu, # activation function\n"], ["pycodestyle", "E266", 13, 0, "too many leading '#' for block comment", "#### sdnn_single_head_KP_yolo model\n"], ["pycodestyle", "E302", 15, 0, "expected 2 blank lines, found 1", "class Network(YOLOBase):\n"], ["pycodestyle", "E402", 9, 0, "module level import not at top of file", "from yolo_base import YOLOBase\n"], ["pycodestyle", "E402", 11, 0, "module level import not at top of file", "from .model_utils import quantize_8bit, quantize_5bit, event_rate, SparsityMonitor\n"], ["pycodestyle", "E501", 11, 80, "line too long (82 > 80 characters)", "from .model_utils import quantize_8bit, quantize_5bit, event_rate, SparsityMonitor\n"], ["pycodestyle", "E501", 25, 80, "line too long (87 > 80 characters)", "        super().__init__(num_classes=num_classes, anchors=anchors, clamp_max=clamp_max)\n"], ["pycodestyle", "E501", 29, 80, "line too long (95 > 80 characters)", "            'tau_grad'      : tau_grad,    # delta unit surrogate gradient relaxation parameter\n"], ["pycodestyle", "E501", 30, 80, "line too long (90 > 80 characters)", "            'scale_grad'    : scale_grad,  # delta unit surrogate gradient scale parameter\n"], ["pycodestyle", "E501", 40, 80, "line too long (90 > 80 characters)", "        self.normalize_mean = torch.tensor([0.485, 0.456, 0.406]).reshape([1, 3, 1, 1, 1])\n"], ["pycodestyle", "E501", 41, 80, "line too long (90 > 80 characters)", "        self.normalize_std  = torch.tensor([0.229, 0.224, 0.225]).reshape([1, 3, 1, 1, 1])\n"], ["pycodestyle", "E501", 48, 80, "line too long (93 > 80 characters)", "        block_5_kwargs = dict(weight_norm=True, delay_shift=False, pre_hook_fx=quantize_5bit)\n"], ["pycodestyle", "E501", 49, 80, "line too long (93 > 80 characters)", "        block_8_kwargs = dict(weight_norm=True, delay_shift=False, pre_hook_fx=quantize_8bit)\n"], ["pycodestyle", "E501", 50, 80, "line too long (85 > 80 characters)", "        neuron_kwargs = {**sdnn_params, 'norm': slayer.neuron.norm.MeanOnlyBatchNorm}\n"], ["pycodestyle", "E501", 57, 80, "line too long (124 > 80 characters)", "            slayer.block.sigma_delta.Conv(neuron_kwargs,   3,  8, 3, padding=1, stride=2, weight_scale=1, **block_8_kwargs),\n"], ["pycodestyle", "E501", 58, 80, "line too long (124 > 80 characters)", "            slayer.block.sigma_delta.Conv(neuron_kwargs,  8,  16, 3, padding=1, stride=2, weight_scale=1, **block_8_kwargs),\n"], ["pycodestyle", "E501", 59, 80, "line too long (125 > 80 characters)", "            slayer.block.sigma_delta.Conv(neuron_kwargs,  16,  32, 3, padding=1, stride=2, weight_scale=1, **block_8_kwargs),\n"], ["pycodestyle", "E501", 60, 80, "line too long (124 > 80 characters)", "            slayer.block.sigma_delta.Conv(neuron_kwargs,  32, 64, 3, padding=1, stride=2, weight_scale=3, **block_8_kwargs),\n"], ["pycodestyle", "E501", 61, 80, "line too long (124 > 80 characters)", "            slayer.block.sigma_delta.Conv(neuron_kwargs, 64, 128, 3, padding=1, stride=1, weight_scale=3, **block_8_kwargs),\n"], ["pycodestyle", "E501", 62, 80, "line too long (125 > 80 characters)", "            slayer.block.sigma_delta.Conv(neuron_kwargs, 128, 128, 3, padding=1, stride=2, weight_scale=3, **block_8_kwargs),\n"], ["pycodestyle", "E501", 63, 80, "line too long (125 > 80 characters)", "            slayer.block.sigma_delta.Conv(neuron_kwargs, 128, 256, 3, padding=1, stride=1, weight_scale=3, **block_5_kwargs),\n"], ["pycodestyle", "E501", 64, 80, "line too long (125 > 80 characters)", "            slayer.block.sigma_delta.Conv(neuron_kwargs, 256, 128, 1, padding=0, stride=1, weight_scale=3, **block_5_kwargs),\n"], ["pycodestyle", "E501", 65, 80, "line too long (125 > 80 characters)", "            slayer.block.sigma_delta.Conv(neuron_kwargs, 128, 256, 3, padding=1, stride=1, weight_scale=3, **block_5_kwargs),\n"], ["pycodestyle", "E501", 69, 80, "line too long (96 > 80 characters)", "            slayer.synapse.Conv(256, self.num_output, 1, padding=0, stride=1, **synapse_kwargs),\n"], ["pycodestyle", "E501", 103, 80, "line too long (81 > 80 characters)", "        return output, torch.FloatTensor(count).reshape((1, -1)).to(input.device)\n"], ["pycodestyle", "E501", 165, 80, "line too long (106 > 80 characters)", "        self.input_blocks[0].neuron.bias.data = saved_model[f'input_blocks.0.neuron.bias'].data.to(device)\n"], ["pycodestyle", "E501", 166, 80, "line too long (128 > 80 characters)", "        self.input_blocks[0].neuron.delta.threshold.data = saved_model[f'input_blocks.0.neuron.delta.threshold'].data.to(device)\n"], ["pycodestyle", "E501", 172, 80, "line too long (89 > 80 characters)", "            self.blocks[i].neuron.bias.data = saved_model[f'blocks.{i}.neuron.bias'].data\n"], ["pycodestyle", "E501", 173, 80, "line too long (115 > 80 characters)", "            self.blocks[i].neuron.norm.running_mean.data = saved_model[f'blocks.{i}.neuron.norm.running_mean'].data\n"], ["pycodestyle", "E501", 174, 80, "line too long (111 > 80 characters)", "            self.blocks[i].neuron.delta.threshold.data = saved_model[f'blocks.{i}.neuron.delta.threshold'].data\n"], ["pycodestyle", "E501", 175, 80, "line too long (99 > 80 characters)", "            self.blocks[i].synapse.weight_g.data = saved_model[f'blocks.{i}.synapse.weight_g'].data\n"], ["pycodestyle", "E501", 176, 80, "line too long (99 > 80 characters)", "            self.blocks[i].synapse.weight_v.data = saved_model[f'blocks.{i}.synapse.weight_v'].data\n"], ["pycodestyle", "E501", 183, 80, "line too long (88 > 80 characters)", "        if self.heads[0].weight.data.shape == saved_model[f'heads.0.weight'].data.shape:\n"], ["pycodestyle", "W293", 95, 0, "blank line contains whitespace", "        \n"], ["pycodestyle", "W293", 143, 0, "blank line contains whitespace", "            \n"], ["pycodestyle", "W293", 150, 0, "blank line contains whitespace", "        \n"], ["pycodestyle", "W503", 149, 20, "line break before binary operator", "                    and b.synapse.weight.requires_grad]\n"]], "digest": "aa94cdd6cb71f0d914bde0954ce68f08"}