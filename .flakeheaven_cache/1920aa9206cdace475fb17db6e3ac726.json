{"results": [["pycodestyle", "E121", 125, 28, "continuation line under-indented for hanging indent", "                            ).long().triu(1).sum(dim=0, keepdim=True).T.expand_as(detections0) == 0\n"], ["pycodestyle", "E126", 124, 32, "continuation line over-indented for hanging indent", "                                ious * label_match > nms_threshold*temporal_scaling_threshold\n"], ["pycodestyle", "E221", 68, 8, "multiple spaces before operator", "    init              = 0\n"], ["pycodestyle", "E221", 69, 14, "multiple spaces before operator", "    detections        = []\n"], ["pycodestyle", "E221", 70, 9, "multiple spaces before operator", "    dets_             = []\n"], ["pycodestyle", "E221", 71, 12, "multiple spaces before operator", "    k_frames          = 2\n"], ["pycodestyle", "E221", 72, 13, "multiple spaces before operator", "    n_batches         = None\n"], ["pycodestyle", "E221", 76, 28, "multiple spaces before operator", "        __class__.detections        = [[] for _ in range(__class__.n_batches)]\n"], ["pycodestyle", "E221", 77, 23, "multiple spaces before operator", "        __class__.dets_             = [deque(maxlen = __class__.k_frames) for _ in range(__class__.n_batches)]\n"], ["pycodestyle", "E221", 78, 22, "multiple spaces before operator", "        __class__.init              = 1\n"], ["pycodestyle", "E225", 90, 25, "missing whitespace around operator", "        if __class__.init==0 or __class__.n_batches != pred.shape[0]:\n"], ["pycodestyle", "E225", 107, 30, "missing whitespace around operator", "            if len(dets_[b_n])==1: ###loads the first frame NMS components discarding NMS\n"], ["pycodestyle", "E225", 113, 20, "missing whitespace around operator", "                if k==max_iterations_temporal-1: # last iteration is classic NMS\n"], ["pycodestyle", "E226", 113, 45, "missing whitespace around arithmetic operator", "                if k==max_iterations_temporal-1: # last iteration is classic NMS\n"], ["pycodestyle", "E226", 124, 66, "missing whitespace around arithmetic operator", "                                ious * label_match > nms_threshold*temporal_scaling_threshold\n"], ["pycodestyle", "E226", 129, 71, "missing whitespace around arithmetic operator", "                    detections01[:,4] = torch.minimum(detections01[:,4]*scaling_prob[0], torch.tensor(1.0))\n"], ["pycodestyle", "E226", 132, 111, "missing whitespace around arithmetic operator", "                    detections0 = torch.cat([detections01, detections00], dim=0) if k < max_iterations_temporal-1 else detections01\n"], ["pycodestyle", "E231", 115, 52, "missing whitespace after ','", "                order0 = torch.argsort(detections0[:,4], descending=True)\n"], ["pycodestyle", "E231", 118, 56, "missing whitespace after ','", "                    order1 = torch.argsort(detections1[:,4], descending=True)\n"], ["pycodestyle", "E231", 129, 34, "missing whitespace after ','", "                    detections01[:,4] = torch.minimum(detections01[:,4]*scaling_prob[0], torch.tensor(1.0))\n"], ["pycodestyle", "E231", 129, 68, "missing whitespace after ','", "                    detections01[:,4] = torch.minimum(detections01[:,4]*scaling_prob[0], torch.tensor(1.0))\n"], ["pycodestyle", "E231", 130, 34, "missing whitespace after ','", "                    detections00[:,4] *= scaling_prob[1]\n"], ["pycodestyle", "E251", 77, 51, "unexpected spaces around keyword / parameter equals", "        __class__.dets_             = [deque(maxlen = __class__.k_frames) for _ in range(__class__.n_batches)]\n"], ["pycodestyle", "E251", 77, 53, "unexpected spaces around keyword / parameter equals", "        __class__.dets_             = [deque(maxlen = __class__.k_frames) for _ in range(__class__.n_batches)]\n"], ["pycodestyle", "E251", 81, 27, "unexpected spaces around keyword / parameter equals", "             conf_threshold = 0.5,\n"], ["pycodestyle", "E251", 81, 29, "unexpected spaces around keyword / parameter equals", "             conf_threshold = 0.5,\n"], ["pycodestyle", "E251", 82, 26, "unexpected spaces around keyword / parameter equals", "             nms_threshold = 0.4,\n"], ["pycodestyle", "E251", 82, 28, "unexpected spaces around keyword / parameter equals", "             nms_threshold = 0.4,\n"], ["pycodestyle", "E251", 83, 23, "unexpected spaces around keyword / parameter equals", "             merge_conf = True,\n"], ["pycodestyle", "E251", 83, 25, "unexpected spaces around keyword / parameter equals", "             merge_conf = True,\n"], ["pycodestyle", "E251", 84, 36, "unexpected spaces around keyword / parameter equals", "             max_iterations_temporal = 15,\n"], ["pycodestyle", "E251", 84, 38, "unexpected spaces around keyword / parameter equals", "             max_iterations_temporal = 15,\n"], ["pycodestyle", "E251", 85, 39, "unexpected spaces around keyword / parameter equals", "             temporal_scaling_threshold = .9,\n"], ["pycodestyle", "E251", 85, 41, "unexpected spaces around keyword / parameter equals", "             temporal_scaling_threshold = .9,\n"], ["pycodestyle", "E251", 86, 25, "unexpected spaces around keyword / parameter equals", "             scaling_prob = [1.15, .85]) -> List[torch.tensor]:\n"], ["pycodestyle", "E251", 86, 27, "unexpected spaces around keyword / parameter equals", "             scaling_prob = [1.15, .85]) -> List[torch.tensor]:\n"], ["pycodestyle", "E261", 97, 43, "at least two spaces before inline comment", "        for b_n, pred_, in enumerate(pred): #along the batch\n"], ["pycodestyle", "E261", 107, 34, "at least two spaces before inline comment", "            if len(dets_[b_n])==1: ###loads the first frame NMS components discarding NMS\n"], ["pycodestyle", "E261", 110, 73, "at least two spaces before inline comment", "                detections0, detections1 = dets_[b_n][-1], dets_[b_n][-2] ###best performer\n"], ["pycodestyle", "E261", 113, 48, "at least two spaces before inline comment", "                if k==max_iterations_temporal-1: # last iteration is classic NMS\n"], ["pycodestyle", "E262", 97, 44, "inline comment should start with '# '", "        for b_n, pred_, in enumerate(pred): #along the batch\n"], ["pycodestyle", "E262", 107, 35, "inline comment should start with '# '", "            if len(dets_[b_n])==1: ###loads the first frame NMS components discarding NMS\n"], ["pycodestyle", "E262", 110, 74, "inline comment should start with '# '", "                detections0, detections1 = dets_[b_n][-1], dets_[b_n][-2] ###best performer\n"], ["pycodestyle", "E265", 105, 12, "block comment should start with '# '", "            #last updated frame in detections0\n"], ["pycodestyle", "E266", 75, 8, "too many leading '#' for block comment", "        ## initialize buffers\n"], ["pycodestyle", "E266", 128, 20, "too many leading '#' for block comment", "                    ### rescaling confidence of bboxes if overlapping and belonging to the same label\n"], ["pycodestyle", "E303", 138, 0, "too many blank lines (3)", "def non_maximum_suppression(predictions: List[torch.tensor],\n"], ["pycodestyle", "E501", 25, 80, "line too long (82 > 80 characters)", "    # implemented the temporal Non Maximum Suppression over two consecutive frames\n"], ["pycodestyle", "E501", 26, 80, "line too long (84 > 80 characters)", "    \"\"\"Performs temporal Non-Maximal suppression of the input predictions. First a basic\n    filtering of the bounding boxes based on a minimum confidence threshold are\n    eliminated. Subsequently we operate a non-maximal suppression is performed maching\n    bboxes over two successive frames. A non-maximal threshold is used to determine if the\n    two bounding boxes represent the same object, above(below) which the likelihood of the\n    object is increased(decreased). It supports batch inputs.\n\n\n    import temporal_NMS as t_nms\n    ### the class is self initialized!! no need to initialize it. Instances can be accessed\n    ### directly calling class_name.instance\n    ### calling the frame predictions to be analyzed, will automatically initialize variables\n    detections = [t_nms.next(predictions[...,t]) for t in T]\n    ### to reset to zero frame data call:\n    t_nms.reset()\n\n    Parameters\n    ----------\n    pred : List[torch.tensor]\n        List of bounding box predictions per batch in\n        (x_center, y_center, width, height) format.\n    conf_threshold : float, optional\n        Confidence threshold, by default 0.5.\n    nms_threshold : float, optional\n        Non maximal overlap threshold, by default 0.4.\n    merge_conf : bool, optional\n        Flag indicating whether to merge objectness score with classification\n        confidence, by default True.\n    max_iterations_temporal : int, optional\n        Maximum limit of temporal iterations (default 15) that scale the class likelihood given the neighboring bboxes.\n    temporal_scaling_threshold : float, optional\n        scaling factor on the nms_threshold for filtering off ious\n    scaling_prob: List of two floats [float, float]\n        scaling of the keep [0] and remove [1] probabilities of neighboring bboxes\n    k_frames: int, optionl - default 2\n\n    Returns\n    -------\n    List[torch.tensor]\n        Non-maximal filterered prediction outputs per batch.\n    \"\"\"\n"], ["pycodestyle", "E501", 28, 80, "line too long (86 > 80 characters)", "    \"\"\"Performs temporal Non-Maximal suppression of the input predictions. First a basic\n    filtering of the bounding boxes based on a minimum confidence threshold are\n    eliminated. Subsequently we operate a non-maximal suppression is performed maching\n    bboxes over two successive frames. A non-maximal threshold is used to determine if the\n    two bounding boxes represent the same object, above(below) which the likelihood of the\n    object is increased(decreased). It supports batch inputs.\n\n\n    import temporal_NMS as t_nms\n    ### the class is self initialized!! no need to initialize it. Instances can be accessed\n    ### directly calling class_name.instance\n    ### calling the frame predictions to be analyzed, will automatically initialize variables\n    detections = [t_nms.next(predictions[...,t]) for t in T]\n    ### to reset to zero frame data call:\n    t_nms.reset()\n\n    Parameters\n    ----------\n    pred : List[torch.tensor]\n        List of bounding box predictions per batch in\n        (x_center, y_center, width, height) format.\n    conf_threshold : float, optional\n        Confidence threshold, by default 0.5.\n    nms_threshold : float, optional\n        Non maximal overlap threshold, by default 0.4.\n    merge_conf : bool, optional\n        Flag indicating whether to merge objectness score with classification\n        confidence, by default True.\n    max_iterations_temporal : int, optional\n        Maximum limit of temporal iterations (default 15) that scale the class likelihood given the neighboring bboxes.\n    temporal_scaling_threshold : float, optional\n        scaling factor on the nms_threshold for filtering off ious\n    scaling_prob: List of two floats [float, float]\n        scaling of the keep [0] and remove [1] probabilities of neighboring bboxes\n    k_frames: int, optionl - default 2\n\n    Returns\n    -------\n    List[torch.tensor]\n        Non-maximal filterered prediction outputs per batch.\n    \"\"\"\n"], ["pycodestyle", "E501", 29, 80, "line too long (90 > 80 characters)", "    \"\"\"Performs temporal Non-Maximal suppression of the input predictions. First a basic\n    filtering of the bounding boxes based on a minimum confidence threshold are\n    eliminated. Subsequently we operate a non-maximal suppression is performed maching\n    bboxes over two successive frames. A non-maximal threshold is used to determine if the\n    two bounding boxes represent the same object, above(below) which the likelihood of the\n    object is increased(decreased). It supports batch inputs.\n\n\n    import temporal_NMS as t_nms\n    ### the class is self initialized!! no need to initialize it. Instances can be accessed\n    ### directly calling class_name.instance\n    ### calling the frame predictions to be analyzed, will automatically initialize variables\n    detections = [t_nms.next(predictions[...,t]) for t in T]\n    ### to reset to zero frame data call:\n    t_nms.reset()\n\n    Parameters\n    ----------\n    pred : List[torch.tensor]\n        List of bounding box predictions per batch in\n        (x_center, y_center, width, height) format.\n    conf_threshold : float, optional\n        Confidence threshold, by default 0.5.\n    nms_threshold : float, optional\n        Non maximal overlap threshold, by default 0.4.\n    merge_conf : bool, optional\n        Flag indicating whether to merge objectness score with classification\n        confidence, by default True.\n    max_iterations_temporal : int, optional\n        Maximum limit of temporal iterations (default 15) that scale the class likelihood given the neighboring bboxes.\n    temporal_scaling_threshold : float, optional\n        scaling factor on the nms_threshold for filtering off ious\n    scaling_prob: List of two floats [float, float]\n        scaling of the keep [0] and remove [1] probabilities of neighboring bboxes\n    k_frames: int, optionl - default 2\n\n    Returns\n    -------\n    List[torch.tensor]\n        Non-maximal filterered prediction outputs per batch.\n    \"\"\"\n"], ["pycodestyle", "E501", 30, 80, "line too long (90 > 80 characters)", "    \"\"\"Performs temporal Non-Maximal suppression of the input predictions. First a basic\n    filtering of the bounding boxes based on a minimum confidence threshold are\n    eliminated. Subsequently we operate a non-maximal suppression is performed maching\n    bboxes over two successive frames. A non-maximal threshold is used to determine if the\n    two bounding boxes represent the same object, above(below) which the likelihood of the\n    object is increased(decreased). It supports batch inputs.\n\n\n    import temporal_NMS as t_nms\n    ### the class is self initialized!! no need to initialize it. Instances can be accessed\n    ### directly calling class_name.instance\n    ### calling the frame predictions to be analyzed, will automatically initialize variables\n    detections = [t_nms.next(predictions[...,t]) for t in T]\n    ### to reset to zero frame data call:\n    t_nms.reset()\n\n    Parameters\n    ----------\n    pred : List[torch.tensor]\n        List of bounding box predictions per batch in\n        (x_center, y_center, width, height) format.\n    conf_threshold : float, optional\n        Confidence threshold, by default 0.5.\n    nms_threshold : float, optional\n        Non maximal overlap threshold, by default 0.4.\n    merge_conf : bool, optional\n        Flag indicating whether to merge objectness score with classification\n        confidence, by default True.\n    max_iterations_temporal : int, optional\n        Maximum limit of temporal iterations (default 15) that scale the class likelihood given the neighboring bboxes.\n    temporal_scaling_threshold : float, optional\n        scaling factor on the nms_threshold for filtering off ious\n    scaling_prob: List of two floats [float, float]\n        scaling of the keep [0] and remove [1] probabilities of neighboring bboxes\n    k_frames: int, optionl - default 2\n\n    Returns\n    -------\n    List[torch.tensor]\n        Non-maximal filterered prediction outputs per batch.\n    \"\"\"\n"], ["pycodestyle", "E501", 35, 80, "line too long (91 > 80 characters)", "    \"\"\"Performs temporal Non-Maximal suppression of the input predictions. First a basic\n    filtering of the bounding boxes based on a minimum confidence threshold are\n    eliminated. Subsequently we operate a non-maximal suppression is performed maching\n    bboxes over two successive frames. A non-maximal threshold is used to determine if the\n    two bounding boxes represent the same object, above(below) which the likelihood of the\n    object is increased(decreased). It supports batch inputs.\n\n\n    import temporal_NMS as t_nms\n    ### the class is self initialized!! no need to initialize it. Instances can be accessed\n    ### directly calling class_name.instance\n    ### calling the frame predictions to be analyzed, will automatically initialize variables\n    detections = [t_nms.next(predictions[...,t]) for t in T]\n    ### to reset to zero frame data call:\n    t_nms.reset()\n\n    Parameters\n    ----------\n    pred : List[torch.tensor]\n        List of bounding box predictions per batch in\n        (x_center, y_center, width, height) format.\n    conf_threshold : float, optional\n        Confidence threshold, by default 0.5.\n    nms_threshold : float, optional\n        Non maximal overlap threshold, by default 0.4.\n    merge_conf : bool, optional\n        Flag indicating whether to merge objectness score with classification\n        confidence, by default True.\n    max_iterations_temporal : int, optional\n        Maximum limit of temporal iterations (default 15) that scale the class likelihood given the neighboring bboxes.\n    temporal_scaling_threshold : float, optional\n        scaling factor on the nms_threshold for filtering off ious\n    scaling_prob: List of two floats [float, float]\n        scaling of the keep [0] and remove [1] probabilities of neighboring bboxes\n    k_frames: int, optionl - default 2\n\n    Returns\n    -------\n    List[torch.tensor]\n        Non-maximal filterered prediction outputs per batch.\n    \"\"\"\n"], ["pycodestyle", "E501", 37, 80, "line too long (93 > 80 characters)", "    \"\"\"Performs temporal Non-Maximal suppression of the input predictions. First a basic\n    filtering of the bounding boxes based on a minimum confidence threshold are\n    eliminated. Subsequently we operate a non-maximal suppression is performed maching\n    bboxes over two successive frames. A non-maximal threshold is used to determine if the\n    two bounding boxes represent the same object, above(below) which the likelihood of the\n    object is increased(decreased). It supports batch inputs.\n\n\n    import temporal_NMS as t_nms\n    ### the class is self initialized!! no need to initialize it. Instances can be accessed\n    ### directly calling class_name.instance\n    ### calling the frame predictions to be analyzed, will automatically initialize variables\n    detections = [t_nms.next(predictions[...,t]) for t in T]\n    ### to reset to zero frame data call:\n    t_nms.reset()\n\n    Parameters\n    ----------\n    pred : List[torch.tensor]\n        List of bounding box predictions per batch in\n        (x_center, y_center, width, height) format.\n    conf_threshold : float, optional\n        Confidence threshold, by default 0.5.\n    nms_threshold : float, optional\n        Non maximal overlap threshold, by default 0.4.\n    merge_conf : bool, optional\n        Flag indicating whether to merge objectness score with classification\n        confidence, by default True.\n    max_iterations_temporal : int, optional\n        Maximum limit of temporal iterations (default 15) that scale the class likelihood given the neighboring bboxes.\n    temporal_scaling_threshold : float, optional\n        scaling factor on the nms_threshold for filtering off ious\n    scaling_prob: List of two floats [float, float]\n        scaling of the keep [0] and remove [1] probabilities of neighboring bboxes\n    k_frames: int, optionl - default 2\n\n    Returns\n    -------\n    List[torch.tensor]\n        Non-maximal filterered prediction outputs per batch.\n    \"\"\"\n"], ["pycodestyle", "E501", 55, 80, "line too long (119 > 80 characters)", "    \"\"\"Performs temporal Non-Maximal suppression of the input predictions. First a basic\n    filtering of the bounding boxes based on a minimum confidence threshold are\n    eliminated. Subsequently we operate a non-maximal suppression is performed maching\n    bboxes over two successive frames. A non-maximal threshold is used to determine if the\n    two bounding boxes represent the same object, above(below) which the likelihood of the\n    object is increased(decreased). It supports batch inputs.\n\n\n    import temporal_NMS as t_nms\n    ### the class is self initialized!! no need to initialize it. Instances can be accessed\n    ### directly calling class_name.instance\n    ### calling the frame predictions to be analyzed, will automatically initialize variables\n    detections = [t_nms.next(predictions[...,t]) for t in T]\n    ### to reset to zero frame data call:\n    t_nms.reset()\n\n    Parameters\n    ----------\n    pred : List[torch.tensor]\n        List of bounding box predictions per batch in\n        (x_center, y_center, width, height) format.\n    conf_threshold : float, optional\n        Confidence threshold, by default 0.5.\n    nms_threshold : float, optional\n        Non maximal overlap threshold, by default 0.4.\n    merge_conf : bool, optional\n        Flag indicating whether to merge objectness score with classification\n        confidence, by default True.\n    max_iterations_temporal : int, optional\n        Maximum limit of temporal iterations (default 15) that scale the class likelihood given the neighboring bboxes.\n    temporal_scaling_threshold : float, optional\n        scaling factor on the nms_threshold for filtering off ious\n    scaling_prob: List of two floats [float, float]\n        scaling of the keep [0] and remove [1] probabilities of neighboring bboxes\n    k_frames: int, optionl - default 2\n\n    Returns\n    -------\n    List[torch.tensor]\n        Non-maximal filterered prediction outputs per batch.\n    \"\"\"\n"], ["pycodestyle", "E501", 59, 80, "line too long (82 > 80 characters)", "    \"\"\"Performs temporal Non-Maximal suppression of the input predictions. First a basic\n    filtering of the bounding boxes based on a minimum confidence threshold are\n    eliminated. Subsequently we operate a non-maximal suppression is performed maching\n    bboxes over two successive frames. A non-maximal threshold is used to determine if the\n    two bounding boxes represent the same object, above(below) which the likelihood of the\n    object is increased(decreased). It supports batch inputs.\n\n\n    import temporal_NMS as t_nms\n    ### the class is self initialized!! no need to initialize it. Instances can be accessed\n    ### directly calling class_name.instance\n    ### calling the frame predictions to be analyzed, will automatically initialize variables\n    detections = [t_nms.next(predictions[...,t]) for t in T]\n    ### to reset to zero frame data call:\n    t_nms.reset()\n\n    Parameters\n    ----------\n    pred : List[torch.tensor]\n        List of bounding box predictions per batch in\n        (x_center, y_center, width, height) format.\n    conf_threshold : float, optional\n        Confidence threshold, by default 0.5.\n    nms_threshold : float, optional\n        Non maximal overlap threshold, by default 0.4.\n    merge_conf : bool, optional\n        Flag indicating whether to merge objectness score with classification\n        confidence, by default True.\n    max_iterations_temporal : int, optional\n        Maximum limit of temporal iterations (default 15) that scale the class likelihood given the neighboring bboxes.\n    temporal_scaling_threshold : float, optional\n        scaling factor on the nms_threshold for filtering off ious\n    scaling_prob: List of two floats [float, float]\n        scaling of the keep [0] and remove [1] probabilities of neighboring bboxes\n    k_frames: int, optionl - default 2\n\n    Returns\n    -------\n    List[torch.tensor]\n        Non-maximal filterered prediction outputs per batch.\n    \"\"\"\n"], ["pycodestyle", "E501", 77, 80, "line too long (110 > 80 characters)", "        __class__.dets_             = [deque(maxlen = __class__.k_frames) for _ in range(__class__.n_batches)]\n"], ["pycodestyle", "E501", 107, 80, "line too long (89 > 80 characters)", "            if len(dets_[b_n])==1: ###loads the first frame NMS components discarding NMS\n"], ["pycodestyle", "E501", 110, 80, "line too long (91 > 80 characters)", "                detections0, detections1 = dets_[b_n][-1], dets_[b_n][-2] ###best performer\n"], ["pycodestyle", "E501", 111, 80, "line too long (119 > 80 characters)", "                # detections0, detections1 = self.dets_[b_n][-1], self.detections[b_n]  ## less good on prev scaled det\n"], ["pycodestyle", "E501", 122, 80, "line too long (108 > 80 characters)", "                        label_match = (detections1[:, 5].reshape(-1, 1) == detections0[:, 5].reshape(1, -1))\n"], ["pycodestyle", "E501", 124, 80, "line too long (93 > 80 characters)", "                                ious * label_match > nms_threshold*temporal_scaling_threshold\n"], ["pycodestyle", "E501", 125, 80, "line too long (99 > 80 characters)", "                            ).long().triu(1).sum(dim=0, keepdim=True).T.expand_as(detections0) == 0\n"], ["pycodestyle", "E501", 127, 80, "line too long (81 > 80 characters)", "                    detections00 = detections0[~keep].reshape(-1, 6).contiguous()\n"], ["pycodestyle", "E501", 128, 80, "line too long (101 > 80 characters)", "                    ### rescaling confidence of bboxes if overlapping and belonging to the same label\n"], ["pycodestyle", "E501", 129, 80, "line too long (107 > 80 characters)", "                    detections01[:,4] = torch.minimum(detections01[:,4]*scaling_prob[0], torch.tensor(1.0))\n"], ["pycodestyle", "E501", 132, 80, "line too long (131 > 80 characters)", "                    detections0 = torch.cat([detections01, detections00], dim=0) if k < max_iterations_temporal-1 else detections01\n"], ["pycodestyle", "W293", 67, 0, "blank line contains whitespace", "    \n"], ["pycodestyle", "W293", 73, 0, "blank line contains whitespace", "    \n"], ["pycodestyle", "W503", 198, 20, "line break before binary operator", "                    == detections[:, 5].reshape(1, -1)\n"], ["pycodestyle", "W503", 509, 8, "line break before binary operator", "        != ann1['annotation']['size']['height']\n"], ["pycodestyle", "W503", 517, 8, "line break before binary operator", "        != ann1['annotation']['size']['width']\n"], ["pycodestyle", "W503", 525, 12, "line break before binary operator", "            + ann1['annotation']['object']}\n"], ["pycodestyle", "W503", 721, 16, "line break before binary operator", "                * 255\n"], ["pycodestyle", "W503", 739, 16, "line break before binary operator", "                * 255\n"]], "digest": "92505887da77db84051b2aead0d71cb2"}